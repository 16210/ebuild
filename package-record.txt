<软件包记录>：
(<类别名称> <非限定的软件包名称> <软件包版本>
  <软件包辅助定位信息> <所在分组列表>
  <启用的应用标志列表> <应用标志列表形式的 IUSE_EFFECTIVE>
  <插槽对>
  四种依赖的<依赖说明符节点*>
  四种依赖的<反向匹配>列表
  <状态>)

<插槽对>：
  (<主插槽> . <子插槽>)

<状态>：
  :not-built	待编译。软件包尚未开始构建
  :built	已编译。软件包正处于安装过程中 src_install() 结束，pkg_preinst() 未开始的状态
  :merged	已合并。软件包处于 pkg_postinst() 执行完毕，但运行依赖不保证满足的状态
  :installed	已安装。软件包的强运行依赖已满足，所有安装过程中该执行的阶段函数都执行完毕

<依赖说明符节点*>：
((<说明符类型> . <依赖说明符内容>) . <匹配情况>)
* <说明符类型> 同 <说明符> 中的 <说明符类型>，即
  :all，:any 或 t。分别代表全选组，任选组，以及原子说明符
* 对于非原子说明符，<依赖说明符内容> 是一张 <依赖说明符节点*> 列表，
  对于原子说明符，<依赖说明符内容> 是一个 <软件包依赖说明符*>
* <匹配情况> 在非原子说明符中取值为 t 或 nil，分别代表已满足和未满足，
  在原子说明符中是一张列表，每个元素是一个状态为已安装的软件包记录的 <软件包版本>，
  表示此软件包能忽略阻塞符地匹配该依赖说明符的一个版本，
  而原子说明符依赖是否满足等价于 <匹配情况> 和是否阻塞的逻辑异或。
* 整个构建/安装/强运行/弱运行依赖的 <依赖说明符节点*> 类型为全选组，没有依赖则节点设为 nil

<反向匹配> 用来记录哪个软件包记录中的依赖说明符匹配到了此软件包，格式如下：
(<类别名称> <非限定的软件包名称> <软件包版本> <路径列表>)
* <路径列表> 中每个元素是一个整数列表，称为 <路径>。
  <路径> 中第一个数字表示从依赖说明符根节点出发到达 <依赖说明符内容> 中索引为几的节点，
  第 n+1 个数字表示从第 n 个数字所到达的节点出发到达 <依赖说明符内容> 中索引为几的节点
